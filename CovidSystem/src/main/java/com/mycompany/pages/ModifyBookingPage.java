package com.mycompany.pages;

// Import(s)
import com.mycompany.api.*;
import com.mycompany.entity.*;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.*;
import javax.swing.DefaultComboBoxModel;
import javax.swing.DefaultListModel;
import javax.swing.JOptionPane;
import java.awt.event.*;
import java.time.temporal.ChronoUnit;

/**
 * This class represents the modify booking page
 */
public class ModifyBookingPage extends javax.swing.JPanel {

    // Manually included variable(s)
    private static final APIFactory<TestingSite> testingSiteFactory = FactoryCreator.getTestingSiteFactory();
    private static final APIFactory<Booking> bookingFactory = FactoryCreator.getBookingFactory();
    
    private Booking currentBooking;
    private String currentBookingId;
    private PreviousBooking selectedPreviousBooking;

    private List<TestingSite> testingSites = new ArrayList<>();
    private List<PreviousBooking> previousBookings;
    private List<Booking> bookings = new ArrayList<>();

    private DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    private DateTimeFormatter dtf2 = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");   
    
    private DefaultComboBoxModel<String> timesComboBoxModel = new DefaultComboBoxModel<>();
    private DefaultComboBoxModel<String> testingSitesComboBoxModel = new DefaultComboBoxModel<>();
    private DefaultListModel<String> listModel = new DefaultListModel<>();
    
    private double waitingTime;
    private int bookingsMatched;
    
    public static final int DAYS_IN_ADVANCE = 8;
    public static final String CHANGE_TO_NEW = "Change To New";
    public static final String CHANGE_TO_PREVIOUS = "Change To Previous";
    public static final String NOT_AVAILABLE = "N/A";
    public static final int SINGLE_CLICK = 1;
    public static final String TIME = "Time";
    public static final String TESTING_SITE_AND_TIME = "Testing Site And Time";
    public static final double FIRST_DOUBLE_DIGIT = 10;
    public static final String PREVIOUS_BOOKING = "Previous Booking";
    
    /**
     * Creates new form ModifyBookingPage
     */
    public ModifyBookingPage() {
        initComponents();
        
        // Obtain list of testing sites from web service
        try
        {
            Get<TestingSite> testingSiteGet = testingSiteFactory.createGet();
            testingSites = testingSiteGet.createGetRequest();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        previousBookingPanel = new javax.swing.JPanel();
        previousBookingPanelLabel = new javax.swing.JLabel();
        previousBookingScrollPane = new javax.swing.JScrollPane();
        previousBookingList = new javax.swing.JList<>();
        newBookingPanel = new javax.swing.JPanel();
        newBookingPanelLabel = new javax.swing.JLabel();
        newTestingSiteLabel = new javax.swing.JLabel();
        newTestingSiteComboBox = new javax.swing.JComboBox<>();
        newTimeLabel = new javax.swing.JLabel();
        newTimeComboBox = new javax.swing.JComboBox<>();
        confirmChangesButton = new javax.swing.JButton();
        previousOrNewToggleButton = new javax.swing.JToggleButton();

        previousBookingPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));

        previousBookingPanelLabel.setText("Change To Previous Booking(s)");

        previousBookingList.setEnabled(false);
        previousBookingList.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                previousBookingListMouseClicked(evt);
            }
        });
        previousBookingScrollPane.setViewportView(previousBookingList);

        javax.swing.GroupLayout previousBookingPanelLayout = new javax.swing.GroupLayout(previousBookingPanel);
        previousBookingPanel.setLayout(previousBookingPanelLayout);
        previousBookingPanelLayout.setHorizontalGroup(
            previousBookingPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(previousBookingPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(previousBookingPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(previousBookingScrollPane)
                    .addGroup(previousBookingPanelLayout.createSequentialGroup()
                        .addComponent(previousBookingPanelLabel)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        previousBookingPanelLayout.setVerticalGroup(
            previousBookingPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, previousBookingPanelLayout.createSequentialGroup()
                .addContainerGap(8, Short.MAX_VALUE)
                .addComponent(previousBookingPanelLabel)
                .addGap(18, 18, 18)
                .addComponent(previousBookingScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 250, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        newBookingPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));

        newBookingPanelLabel.setText("Change To New Testing Site/Time");

        newTestingSiteLabel.setText("New Testing Site:");

        newTimeLabel.setText("New Time:");

        javax.swing.GroupLayout newBookingPanelLayout = new javax.swing.GroupLayout(newBookingPanel);
        newBookingPanel.setLayout(newBookingPanelLayout);
        newBookingPanelLayout.setHorizontalGroup(
            newBookingPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(newBookingPanelLayout.createSequentialGroup()
                .addGroup(newBookingPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(newBookingPanelLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(newBookingPanelLabel))
                    .addGroup(newBookingPanelLayout.createSequentialGroup()
                        .addGap(139, 139, 139)
                        .addGroup(newBookingPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(newBookingPanelLayout.createSequentialGroup()
                                .addComponent(newTestingSiteLabel)
                                .addGap(18, 18, 18)
                                .addComponent(newTestingSiteComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 400, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(newBookingPanelLayout.createSequentialGroup()
                                .addComponent(newTimeLabel)
                                .addGap(18, 18, 18)
                                .addComponent(newTimeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))))
                .addContainerGap(138, Short.MAX_VALUE))
        );

        newBookingPanelLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {newTestingSiteComboBox, newTimeComboBox});

        newBookingPanelLayout.setVerticalGroup(
            newBookingPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(newBookingPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(newBookingPanelLabel)
                .addGap(33, 33, 33)
                .addGroup(newBookingPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(newTestingSiteComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(newTestingSiteLabel))
                .addGap(39, 39, 39)
                .addGroup(newBookingPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(newTimeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(newTimeLabel))
                .addContainerGap(60, Short.MAX_VALUE))
        );

        confirmChangesButton.setText("Confirm Change(s)");
        confirmChangesButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                confirmChangesButtonActionPerformed(evt);
            }
        });

        previousOrNewToggleButton.setText("Change To Previous");
        previousOrNewToggleButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                previousOrNewToggleButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(previousBookingPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(175, 175, 175)
                        .addComponent(previousOrNewToggleButton)
                        .addGap(45, 45, 45)
                        .addComponent(confirmChangesButton, javax.swing.GroupLayout.PREFERRED_SIZE, 200, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, 0))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(newBookingPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addContainerGap())
        );

        layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {confirmChangesButton, previousOrNewToggleButton});

        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(previousBookingPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(newBookingPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 27, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(confirmChangesButton)
                    .addComponent(previousOrNewToggleButton))
                .addGap(39, 39, 39))
        );
    }// </editor-fold>//GEN-END:initComponents

    // The next 3 methods are used to handle previousBookings like a queue
    // First in, first out
    private void setPreviousBookings(List<PreviousBooking> pb)  {previousBookings = pb;}
    
    private void addNewPreviousBooking(PreviousBooking newPreviousBooking)
    {
        if (previousBookings.size() == 3)
        {
            previousBookings.remove(0);
            previousBookings.add(newPreviousBooking);
        }
        else if ((previousBookings.size() >= 0) && (previousBookings.size() < 3))
        {
            previousBookings.add(newPreviousBooking);
        }
    }
    
    private void removePreviousBooking(int previousBookingIndex)
    {
        if (previousBookings.size() > 0)
        {
            previousBookings.remove(previousBookingIndex);
        }
    }
    
    // This method sets the booking to be modified
    public void setBooking(Booking booking)
    {
        currentBooking = booking;
        currentBookingId = currentBooking.getId();
    }
    
    // This method displays all the testing sites
    public void getTestingSites()
    {
        testingSitesComboBoxModel.removeAllElements();
        newTestingSiteComboBox.setModel(testingSitesComboBoxModel);
        
        // Add "N/A" as the first element
        testingSitesComboBoxModel.addElement(NOT_AVAILABLE);

        for (TestingSite testingSite: testingSites)
        {
            testingSitesComboBoxModel.addElement(testingSite.getName());
        }
    }
    
    // This method displays the available booking times
    // Book anywhere between 1 day to 7 days in advance
    public void getTimes()
    {
        LocalDateTime now = LocalDateTime.now();
        timesComboBoxModel.removeAllElements();
        newTimeComboBox.setModel(timesComboBoxModel);

        // Add "N/A" as the first element
        timesComboBoxModel.addElement(NOT_AVAILABLE);

        for (int i = 1; i < DAYS_IN_ADVANCE; i++)
        {
            timesComboBoxModel.addElement(dtf.format(now.plusDays(i)));
        }
    }
    
    // This method displays the available previous booking(s)
    public void getPreviousBookings()
    {
        System.out.println("Line 298: getPreviousBookings method begins\n");
        previousBookingList.setEnabled(true);
        listModel.removeAllElements();
        previousBookingList.setModel(listModel);
        previousBookings = currentBooking.getAdditionalInfo().getPreviousBookings();
     
        if (previousBookings == null)
        {
            previousBookings = new ArrayList<>();
            listModel.addElement("No previous bookings");
            previousBookingList.setModel(listModel);
            previousBookingList.setEnabled(false);
            System.out.println("Line 310: List of previous bookings is null, so now it is created for the first time, is empty");
        }
        else if (previousBookings.isEmpty() == true)
        {
            listModel.addElement("No previous bookings");
            previousBookingList.setModel(listModel);
            previousBookingList.setEnabled(false);
            System.out.println("Line 317: List of previous bookings is not null, but is empty");
        }
        else
        {
            System.out.println("Line 321: When I first load my list of previous bookings, see what is inside: \n");
            for (PreviousBooking previousBooking: previousBookings)
            {
                String bookingDetails = String.format("%s | %s | %s",
                        previousBooking.getTestingSiteId(),
                        previousBooking.getTestingSiteName(),
                        previousBooking.getStartTime());

                listModel.addElement(bookingDetails);

                System.out.println("Line 331: " + bookingDetails);
            }
            previousBookingList.setModel(listModel);
        }
        System.out.println("Line 335: getPreviousBookings finished executing");
        System.out.println("________________________________________________________________________\n");
    }
    
    // This method is used to construct the JSON string for the list of previous bookings
    // Previous bookings is the same as previous changes of a booking
    private String setPreviousBookingsJsonString()
    {
        String jsonString = "\"previousBookings\":[";
        for (int i = 0; i < previousBookings.size(); i++)
        {
            if (i != previousBookings.size() - 1)
            {
                String pb = "{" + 
                        "\"timestamp\":\"" + previousBookings.get(i).getTimestamp() + "\"," +
                        "\"testingSiteId\":\"" + previousBookings.get(i).getTestingSiteId() + "\"," +
                        "\"testingSiteName\":\"" + previousBookings.get(i).getTestingSiteName() + "\"," +
                        "\"startTime\":\"" + previousBookings.get(i).getStartTime() + "\"" +
                        "},";
                jsonString = jsonString + pb;
            }
            else
            {
                String pb = "{" + 
                        "\"timestamp\":\"" + previousBookings.get(i).getTimestamp() + "\"," +                       
                        "\"testingSiteId\":\"" + previousBookings.get(i).getTestingSiteId() + "\"," +
                        "\"testingSiteName\":\"" + previousBookings.get(i).getTestingSiteName() + "\"," +
                        "\"startTime\":\"" + previousBookings.get(i).getStartTime() + "\"" +
                        "}";
                jsonString = jsonString + pb;
            }
        }
        jsonString = jsonString + "]"; 
        return jsonString;
    }
    
    // This method updates the state of the current booking
    public void updateCurrentBookingState()
    {
        System.out.println("Line 374: updateCurrentBookingState method begins\n");
        try
        {
            Get<Booking> bookingGet = bookingFactory.createGet();
            bookings = bookingGet.createGetRequest();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }   
        
        // Update the state of the current booking
        // So that the latest data can be displayed
        for (Booking b: bookings)
        {
            if (currentBookingId.equals(b.getId()))
            {
                currentBooking = b;
                currentBookingId = currentBooking.getId();
                previousBookings = currentBooking.getAdditionalInfo().getPreviousBookings();
            }
        }
        
        listModel.removeAllElements();
        previousBookingList.setModel(listModel);
        System.out.println("Line 399: When I first load my UPDATED list of previous bookings, after obtaining it from web service: \n");
        for (PreviousBooking previousBooking: previousBookings)
        {
            String bookingDetails = String.format("%s | %s | %s",
                    previousBooking.getTestingSiteId(),
                    previousBooking.getTestingSiteName(),
                    previousBooking.getStartTime());
            
            listModel.addElement(bookingDetails);
            
            System.out.println("Line 409: " + bookingDetails);
        }
        previousBookingList.setModel(listModel);
        System.out.println("Line 412: updateCurrentBookingState finished executing");
        System.out.println("________________________________________________________________________\n");
    }
    
    // This method does the modifcation of booking
    // By patching the booking
    private void modifyBooking(String testingSiteId, String time)
    {
        System.out.println("Line 420: modifyBooking method begins\n");
        // Time and date here are used interchangeably
        // Modify and change here are used interchangeably
     
        TestingSite testingSite = null;
        for (TestingSite ts: testingSites)
        {
            if (ts.getId().equals(testingSiteId))
            {
                testingSite = ts;
            }
        }
        
        // Create a new start time based on the chosen time 
        // First, obtain the waiting time
        // Each booking increases the waiting time by 30 minutes = 0.5 hours
        List<Booking> testingSiteBookings = testingSite.getBookings();
        bookingsMatched = 0;
        for (Booking booking: testingSiteBookings)
        {
            String startTime = booking.getStartTime();
            Instant instant = Instant.parse(startTime);
            LocalDateTime datetime = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);
            String bookingTime = dtf.format(datetime);
            if (bookingTime.equals(time))
            {
                bookingsMatched++;
            }
        }
        waitingTime = bookingsMatched * 0.5;
        
        // To create start time
        // Waiting time + opening hour of testing site
        // The obtained result is the time, in the form of a number with the type as double
        // Obtain the date as a string
        // Format time and date into a String with Instant format
        // Instant format is used because that is how it is stored in the web service
        String tsoh = testingSite.getAdditionalInfo().getOpeningTime().substring(0, 2);
        int testingSiteOpeningHour = Integer.parseInt(tsoh);
        double newStartHour = waitingTime + Double.valueOf(testingSiteOpeningHour);
        String newStartTime;
        
        // Check if newStartHour has decimal of ".5"
        // ".5" here indicates 30 minutes
        // If it has a decimal of ".5"
        // "30" is added
        if (newStartHour % 1 != 0)
        {
            double flooredNewStartHour = Math.floor(newStartHour);
            if (newStartHour < FIRST_DOUBLE_DIGIT)
            {   
                newStartTime = String.format("%sT0%d:30:00.000Z", time, (int) flooredNewStartHour);  
            }
            else
            {
                newStartTime = String.format("%sT%d:30:00.000Z", time, (int) flooredNewStartHour);  
            }
        }
        // If it does not have a decimal of ".5"
        // "30" is not added
        else
        {
            if (newStartHour < FIRST_DOUBLE_DIGIT)
            {   
                newStartTime = String.format("%sT0%d:00:00.000Z", time, (int) newStartHour);  
            }
            else
            {
                newStartTime = String.format("%sT%d:00:00.000Z", time, (int) newStartHour);  
            }
        }
        
        // Only change time
        if (testingSiteId.equals(currentBooking.getTestingSite().getId()) == true)
        {
            // Get current time as timestamp of change
            LocalDateTime now = LocalDateTime.now();
            String timestamp = dtf2.format(now);
            
            // Create new entry of previous booking
            PreviousBooking newPreviousBooking = new PreviousBooking(
                    timestamp,
                    currentBooking.getTestingSite().getId(), 
                    currentBooking.getTestingSite().getName(), 
                    currentBooking.getStartTime());
            
            // Update list of previous bookings
            // Add new entry of previous booking
            addNewPreviousBooking(newPreviousBooking);

            System.out.println("Line 509: My UPDATED list of previous bookings, that I'm going to send to the web service: \n");
            for (PreviousBooking pb: previousBookings)
            {
                String bookingDetails = String.format("%s | %s | %s",
                        pb.getTestingSiteId(),
                        pb.getTestingSiteName(),
                        pb.getStartTime());
                
                System.out.println("Line 517: " + bookingDetails);
            }
            System.out.println("_____________________________________________________________\n");
            
            // Obtain JSON string of the updated list of previous bookings
            String jsonString = setPreviousBookingsJsonString();
            
            // Patch the Booking object and send it to the web service
            // Notify that the required details are sent
            try
            {
                System.out.println(
                "Line 529: Only change time\n" +
                "New start time: " + newStartTime + "\n");
                System.out.println("Line 531: Booking patch has been called");
                Patch bookingPatch = bookingFactory.createPatch();
                bookingPatch.createPatchRequest(newStartTime, currentBooking.getId(), jsonString, TIME);             
                JOptionPane.showMessageDialog(null, "Booking time has been modified successfully.", "Booking Modification", JOptionPane.INFORMATION_MESSAGE);
            }
            catch (Exception e)
            {
                JOptionPane.showMessageDialog(null, e.getMessage(), "Booking Modification", JOptionPane.ERROR_MESSAGE);
            }
        }
        // Change testing site and time
        else
        {
            // Get current time as timestamp of change
            LocalDateTime now = LocalDateTime.now();
            String timestamp = dtf2.format(now);
            
            // Get name of new testing site
            String testingSiteName = "";
            for (TestingSite ts: testingSites)
            {
                if (ts.getId().equals(testingSiteId))
                {
                    testingSiteName = ts.getName();
                }
            }
            
            // Create new entry of previous booking
            PreviousBooking newPreviousBooking = new PreviousBooking(
                    timestamp,
                    currentBooking.getTestingSite().getId(), 
                    currentBooking.getTestingSite().getName(), 
                    currentBooking.getStartTime());
            
            // Update list of previous bookings
            // Add new entry of previous booking
            addNewPreviousBooking(newPreviousBooking);
            
            System.out.println("Line 569: My UPDATED list of previous bookings, that I'm going to send to the web service: \n");
            for (PreviousBooking previousBooking: previousBookings)
            {
                String bookingDetails = String.format("%s | %s | %s",
                        previousBooking.getTestingSiteId(),
                        previousBooking.getTestingSiteName(),
                        previousBooking.getStartTime());
                
                System.out.println("Line 577: " + bookingDetails);
            }
            System.out.println("_____________________________________________________________\n");
            
            // Obtain JSON string of list of previous bookings
            String jsonString = setPreviousBookingsJsonString();
            
            // Patch the Booking object and send it to the web service
            // Notify that the required details are sent
            try
            {
                String tsite = "";
                for (TestingSite ts: testingSites)
                {
                    if (ts.getId().equals(testingSiteId))
                    {
                        tsite = ts.getName();
                    }
                }
                System.out.println(
                "Line 597: Only change time\n" +
                "New start time: " + newStartTime + "\n" +
                "New testing site: " + tsite + "\n");
                System.out.println("Line 600: Booking patch has been called");
                Patch bookingPatch = bookingFactory.createPatch();
                bookingPatch.createPatchRequest(testingSiteId, newStartTime, currentBooking.getId(), jsonString, TESTING_SITE_AND_TIME);
                JOptionPane.showMessageDialog(null, "Booking testing site and time has been modified successfully.", "Booking Modification", JOptionPane.INFORMATION_MESSAGE);
            }
            catch (Exception e)
            {
                JOptionPane.showMessageDialog(null, e.getMessage(), "Booking Modification", JOptionPane.ERROR_MESSAGE);
            }
        }
        
        // Update/refresh the state of the current booking
        updateCurrentBookingState();
        System.out.println("Line 613: modifyBooking finished executing");
        System.out.println("________________________________________________________________________\n");
    }
    
    // This method determines which panel to enable
    // Only one panel can be enabled at any given time
    private void previousOrNewToggleButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_previousOrNewToggleButtonActionPerformed
        if (previousOrNewToggleButton.isSelected())
        {
            previousOrNewToggleButton.setText(CHANGE_TO_NEW);
            previousBookingList.setEnabled(true);
            newTestingSiteComboBox.setEnabled(false);
            newTimeComboBox.setEnabled(false);
        }
        else
        {
            previousOrNewToggleButton.setText(CHANGE_TO_PREVIOUS);
            previousBookingList.setEnabled(false);
            newTestingSiteComboBox.setEnabled(true);
            newTimeComboBox.setEnabled(true);
        }
    }//GEN-LAST:event_previousOrNewToggleButtonActionPerformed

    // This method confirms the made changes
    // Performs checking to see if the changes are valid
    private void confirmChangesButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_confirmChangesButtonActionPerformed
        System.out.println("Line 639: confirmChangesButtonActionPerformed method begins");
        // Change to a previous booking
        if (previousOrNewToggleButton.isSelected())
        {
            Boolean exist = false;
            // Check if there are no previous bookings
            if (previousBookings == null)
            {
                JOptionPane.showMessageDialog(null, "Previous bookings do not exist.", "Booking Modification", JOptionPane.ERROR_MESSAGE);        
            }
            else if (previousBookings.isEmpty())
            {
                JOptionPane.showMessageDialog(null, "Previous bookings do not exist.", "Booking Modification", JOptionPane.ERROR_MESSAGE);        
            }
            else if (selectedPreviousBooking == null)
            {
                JOptionPane.showMessageDialog(null, "No previous booking has been selected.", "Booking Modification", JOptionPane.ERROR_MESSAGE);  
            }
            else
            {
                exist = true;
            }
            
            if (exist == true)
            {
                // The testing site and time of the selected previous booking
                String testingSiteId = selectedPreviousBooking.getTestingSiteId();
                String startTime = selectedPreviousBooking.getStartTime();

                // Update list of previous bookings
                // Remove the selected previous booking from the list of previous bookings
                for (int i = 0; i < previousBookings.size(); i++)
                {
                    if ((previousBookings.get(i).getTestingSiteId().equals(testingSiteId) == true) && (previousBookings.get(i).getStartTime().equals(startTime)))
                    {
                        removePreviousBooking(i);
                    }
                }
                
                System.out.println("Line 678: My UPDATED list of previous bookings, that I'm going to send to the web service: \n");
                for (PreviousBooking previousBooking: previousBookings)
                {
                    String bookingDetails = String.format("%s | %s | %s",
                            previousBooking.getTestingSiteId(),
                            previousBooking.getTestingSiteName(),
                            previousBooking.getStartTime());

                    System.out.println("Line 686: " + bookingDetails);

                }
                System.out.println("_____________________________________________________________\n");

                try
                {
                    // Update the list of previous bookings
                    String jsonString = setPreviousBookingsJsonString();
                                        
                    Patch bookingPatch = bookingFactory.createPatch();
                    bookingPatch.createPatchRequest(testingSiteId, startTime, currentBooking.getId(), jsonString, PREVIOUS_BOOKING);
                    JOptionPane.showMessageDialog(null, "Current booking has been reverted to a previous booking.", "Booking Modification", JOptionPane.INFORMATION_MESSAGE);
                }
                catch (Exception e)
                {
                    JOptionPane.showMessageDialog(null, e.getMessage(), "Booking Modification", JOptionPane.ERROR_MESSAGE);
                }
                
                // Update/refresh the state of the current booking
                updateCurrentBookingState();                
            }
        }
        // Change to a new testing site/time
        // Only two options
        // First option, only change time
        // Second option, change testing site and time
        else
        {
            Boolean conflict = false;
            String testingSite = newTestingSiteComboBox.getSelectedItem().toString();
            String time = newTimeComboBox.getSelectedItem().toString();
            
            // First, check which option has been made
            
            // If nothing has been selected, notify as error
            if ((testingSite.equals(NOT_AVAILABLE) == true) && (time.equals(NOT_AVAILABLE) == true))
            {
                JOptionPane.showMessageDialog(null, "Nothing has been selected.", "Booking Modification", JOptionPane.ERROR_MESSAGE);
            }
            // If only testing site is selected, notify as error
            // It is not allowed to only change testing site
            if ((testingSite.equals(NOT_AVAILABLE) == false) && (time.equals(NOT_AVAILABLE) == true))
            {
                JOptionPane.showMessageDialog(null, "Only changing testing site is not allowed.", "Booking Modification", JOptionPane.ERROR_MESSAGE);
            }
            // Only change time
            else if ((testingSite.equals(NOT_AVAILABLE) == true) && (time.equals(NOT_AVAILABLE) == false))
            {
                // Check with every previous booking's testing site and time
                // If there is a conflict, the change of time is not allowed
                // Reject modification
                if (previousBookings != null)
                {
                    for (PreviousBooking pb: previousBookings)
                    {
                        String previousBookingTestingSiteId = pb.getTestingSiteId();
                        String previousBookingStartTime = pb.getStartTime();

                        Instant instant = Instant.parse(previousBookingStartTime);
                        LocalDateTime datetime = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);
                        String previousBookingTime = dtf.format(datetime);
                        if ((time.equals(previousBookingTime)) && (currentBooking.getTestingSite().getId().equals(previousBookingTestingSiteId)))
                        {
                            System.out.println("Line 750: There is a conflict, current testing site and new time matches with testing site and time of a previous booking\n");
                            conflict = true;
                            JOptionPane.showMessageDialog(null, "A previous booking with the same testing site and time exists.", "Booking Modification", JOptionPane.ERROR_MESSAGE);  
                            break;
                        }
                    }
                }
                
                // Check with current booking's testing site and time
                // If the current time is the same as the new time
                // Reject modification             
                String currentBookingTime = currentBooking.getStartTime();
                Instant currentBookingInstant = Instant.parse(currentBookingTime);
                Instant compareCurrentBookingDate = currentBookingInstant.truncatedTo(ChronoUnit.DAYS);

                String startTime = time + "T00:00:00.000Z";
                Instant bookingInstant = Instant.parse(startTime);
                Instant compareBookingDate = bookingInstant.truncatedTo(ChronoUnit.DAYS);

                int value = compareCurrentBookingDate.compareTo(compareBookingDate);
                
                if (value == 0)
                {
                    conflict = true;
                    JOptionPane.showMessageDialog(null, "Modification cannot have time unchanged.", "Booking Modification", JOptionPane.ERROR_MESSAGE);    
                }
                
                // If there is no conflict, the change of time is allowed
                if (conflict == false)
                {
                    modifyBooking(currentBooking.getTestingSite().getId(), time);
                }
            }
            // Change testing site and time
            else if ((testingSite.equals(NOT_AVAILABLE) == false) && (time.equals(NOT_AVAILABLE) == false))
            {
                String testingSiteId = "";
                for (TestingSite ts: testingSites)
                {
                    if (ts.getName().equals(testingSite))
                    {
                        testingSiteId = ts.getId();
                    }
                }
                
                // Check with every previous booking's testing site and time
                // If there is a conflict, the change of testing site and time is not allowed
                // Reject modification
                if (previousBookings != null)
                {
                    for (PreviousBooking pb: previousBookings)
                    {
                        String previousBookingTestingSiteId = pb.getTestingSiteId();
                        String previousBookingStartTime = pb.getStartTime();

                        Instant instant = Instant.parse(previousBookingStartTime);
                        LocalDateTime datetime = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);
                        String previousBookingTime = dtf.format(datetime);
                        if ((time.equals(previousBookingTime)) && (testingSiteId.equals(previousBookingTestingSiteId)))
                        {
                            System.out.println("Line 810: There is a conflict, new testing site and new time matches with testing site and time of a previous booking\n");
                            conflict = true;
                            JOptionPane.showMessageDialog(null, "A previous booking with the same testing site and time exists.", "Booking Modification", JOptionPane.ERROR_MESSAGE);   
                            break;
                        }
                    }
                }
                
                // Check with current booking's testing site and time
                // If the current testing site and time are the same as the new testing site and time
                // Reject modification
                String currentBookingTime = currentBooking.getStartTime();
                Instant currentBookingInstant = Instant.parse(currentBookingTime);
                Instant compareCurrentBookingDate = currentBookingInstant.truncatedTo(ChronoUnit.DAYS);

                String startTime = time + "T00:00:00.000Z";
                Instant bookingInstant = Instant.parse(startTime);
                Instant compareBookingDate = bookingInstant.truncatedTo(ChronoUnit.DAYS);

                int value = compareCurrentBookingDate.compareTo(compareBookingDate);

                if ((value == 0) && (currentBooking.getTestingSite().getName().equals(testingSite) == true))
                {
                    conflict = true;
                    JOptionPane.showMessageDialog(null, "Modification cannot have both testing site and time unchanged.", "Booking Modification", JOptionPane.ERROR_MESSAGE);    
                }

                // If there is no conflict, the change of testing site and time is allowed
                if (conflict == false)
                {
                    modifyBooking(testingSiteId, time);
                }                
            }
        }
        
        System.out.println("Line 845: confirmChangesButtonActionPerformed finished executing");
        System.out.println("________________________________________________________________________\n");
    }//GEN-LAST:event_confirmChangesButtonActionPerformed

    // This method stores the selected previous booking
    private void previousBookingListMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_previousBookingListMouseClicked
        if (evt.getClickCount() == SINGLE_CLICK && evt.getButton() == MouseEvent.BUTTON1)
        {
            int selectedPreviousBookingIndex = previousBookingList.getSelectedIndex();
            selectedPreviousBooking = previousBookings.get(selectedPreviousBookingIndex);
        }
    }//GEN-LAST:event_previousBookingListMouseClicked

    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton confirmChangesButton;
    private javax.swing.JPanel newBookingPanel;
    private javax.swing.JLabel newBookingPanelLabel;
    private javax.swing.JComboBox<String> newTestingSiteComboBox;
    private javax.swing.JLabel newTestingSiteLabel;
    private javax.swing.JComboBox<String> newTimeComboBox;
    private javax.swing.JLabel newTimeLabel;
    private javax.swing.JList<String> previousBookingList;
    private javax.swing.JPanel previousBookingPanel;
    private javax.swing.JLabel previousBookingPanelLabel;
    private javax.swing.JScrollPane previousBookingScrollPane;
    private javax.swing.JToggleButton previousOrNewToggleButton;
    // End of variables declaration//GEN-END:variables
}
